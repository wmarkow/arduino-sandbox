#include <Arduino.h>
#include "afsk.h"
#include "../fsk/fsk.h"

#define MICROS_DURATIN_US 43
#define AFSK1200_SPACE_HALF_DURATION_US (227 - 33 + 10)
#define AFSK1200_SPACE_HALF_SHORT_DURATION_US (227 - 33 - 76 + 50)
#define AFSK1200_MARK_HALF_DURATION_US (417 - 37 + 20)

uint8_t lastSentSymbol = 1; // meaning MARK as default
uint8_t countOfOnes = 0;
volatile uint8_t intCount = 0;

void afsk_send_aprs_byte_no_bit_stuffing(char byte);
void afsk_send_aprs_byte_bit_stuffing(char byte);
void afsk_aprs_send_space();
void afsk_aprs_send_mark();

bool afsk_tone(uint16_t freqHz, unsigned long durationUs)
{
    unsigned long delayUs = 1000000L / freqHz / 2;
    unsigned long secondDelayUs = delayUs - MICROS_DURATIN_US;
    unsigned long start = micros();

    do
    {
        fsk_tx_direct_bit_high();
        delayMicroseconds(delayUs);
        fsk_tx_direct_bit_low();
        delayMicroseconds(secondDelayUs);
    }
    while(micros() - start < durationUs);
}

void afsk_send_aprs_init()
{
    lastSentSymbol = 0;
    countOfOnes = 0;
    intCount = 0;

    // configure TIM2
    // We need to generate 1200Hz and 2200Hz audio tones.
    // For this to happen we need to toggle data pin with twice
    // a faster frequency: 2400Hz and 4400Hz. The least common multiple frequency
    // of those two numbers is 24600Hz, which must be generated by the timer. 
    // Then:
    // a) every 11 interrupt tick we need to toggle the pin to generate 1200Hz tone
    // b) every 6 interrupt tick we eed to toggle the pin to generate 2200Hz tone
    // c) every 22 interrupt tick a new bit starts to be transmitted

    // Prescaler register
    TIM2->PSCR = 1; // 2^1 = 2, 16MHz/2 = 8MHz
    // set Counter Auto-Reload Registers - TIM2->ARR=303 == 0x012F,
    // theoretically giving interrupt frequency 26402.6 Hz
    TIM2->ARRH = 0x01;
    TIM2->ARRL = 0x45; // practically the counter needs to be a bit higher 
    // TIM2->IER (Interrupt Enable Register), Update interrupt (UIE) (bit 0)
    TIM2->IER |= TIM2_IER_UIE;

    // TIM2->CR1 â€“ Timer 2 Control Register 1, Counter ENable bit (CEN) (bit 0)
    //TIM2->CR1 |= TIM2_CR1_CEN;
}

void afsk_send_aprs_packet(char* packet, uint8_t length)
{
    TIM2->CR1 |= TIM2_CR1_CEN; // enable TIM2

    for(uint8_t q = 0 ; q < 40 ; q++)
    {
        afsk_send_aprs_byte_no_bit_stuffing(0x7E);
    }

    for(uint8_t q = 0 ; q < length ; q++)
    {
        afsk_send_aprs_byte_bit_stuffing(packet[q]);
    }

    for(uint8_t q = 0 ; q < 40 ; q++)
    {
        afsk_send_aprs_byte_no_bit_stuffing(0x7E);
    }

    TIM2->CR1 &= ~TIM2_CR1_CEN; // disable TIM2
}

void afsk_send_aprs_byte_no_bit_stuffing(char byte)
{
    //Serial_print_s(" Sending byte ");
    Serial_println_i(byte);

    for(int q = 0 ; q < 8 ; q++)
    {
        if((byte & 0x01) == 0x01)
        {
            //Serial_println_s("Sending bit 1");
            // bit 1: repeat last sent symbol
            if(lastSentSymbol == 1)
            {
                //Serial_println_s("Last sent was MARK. Sending symbol MARK");
                afsk_aprs_send_mark();
            }
            else
            {
                //Serial_println_s("Last sent was SPACE. Sending symbol SPACE");
                afsk_aprs_send_space();
            }
        }
        else
        {
            //Serial_println_s("Sending bit 0");
            // bit 0: switch to the other symbol
            if(lastSentSymbol == 1)
            {
                //Serial_println_s("Last sent was MARK. Sending symbol SPACE");
                afsk_aprs_send_space();
                lastSentSymbol = 0;
            }
            else
            {
                //Serial_println_s("Last sent was SPACE. Sending symbol MARK");
                afsk_aprs_send_mark();
                lastSentSymbol = 1;
            }
        }
        byte >>= 1;
    }
}

void afsk_send_aprs_byte_bit_stuffing(char byte)
{
    for(int q = 0 ; q < 8 ; q++)
    {
        if((byte & 0x01) == 0x01)
        {
            countOfOnes ++;

            // bit 1: repeat last sent symbol
            if(lastSentSymbol == 1)
            {
                afsk_aprs_send_mark();
            }
            else
            {
                afsk_aprs_send_space();
            }
        }

        // send standard bit 0 or additional bit 0 when in bit stuffing
        if(((byte & 0x01) == 0x00) || (countOfOnes == 5))
        {
            countOfOnes = 0;

            // bit 0: switch to the other symbol
            if(lastSentSymbol == 1)
            {
                afsk_aprs_send_space();
                lastSentSymbol = 0;
            }
            else
            {
                afsk_aprs_send_mark();
                lastSentSymbol = 1;
            }
        }

        byte >>= 1;
    }
}

volatile bool bitToSend = false;
volatile bool giveMeNextBit = false;

/*
 * Sends the space tone (2200Hz, typically a binary 0 if not using extra encoding, i.e. NRZI)
 */
inline void afsk_aprs_send_space()
{
    bitToSend = false;
    giveMeNextBit = false;
     while(!giveMeNextBit)
     {
         // do nothing; just wait
     }
}

/*
 * Sends the mark tone (1200Hz, typically a binary 1 if not using extra encoding, i.e. NRZI)
 */
inline void afsk_aprs_send_mark()
{
    bitToSend = true;
    giveMeNextBit = false;
     while(!giveMeNextBit)
     {
         // do nothing; just wait
     }
}

INTERRUPT_HANDLER(TIM2_UPD_OVF_BRK_IRQHandler, ITC_IRQ_TIM1_OVF)
{
    // Clear Timer 2 Status Register 1 Update Interrupt Flag (UIF) (bit 0)
    TIM2->SR1 &= ~TIM2_SR1_UIF;

    intCount ++;

    if(bitToSend)
    {
        if(intCount == 11)
        {
            fsk_tx_direct_bit_high();
            return;
        }
    }
    else
    {
        if(intCount == 6)
        {
            fsk_tx_direct_bit_high();
            return;
        }
        else if(intCount == 12)
        {
            fsk_tx_direct_bit_low();
            return;
        }
        else if(intCount == 18)
        {
            fsk_tx_direct_bit_high();
            return;
        }
    }

    if(intCount == 22)
    {
        fsk_tx_direct_bit_low();
        intCount = 0;
        giveMeNextBit = true;
    }
}

